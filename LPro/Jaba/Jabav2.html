<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--████████████████████████████████████████████████████████████████████████████████████-->
	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--████████████████████████████████████████████████████████-->
<!--████████████████████████████-->
	<head>

	<title>2 java</title>

	<meta http-equip="Content-Type" content="text/html" charset="UTF-8" />
	<meta name="description" content="обучающий проект, java" />
	<meta name="keywords" content="ключ, обучение, хтмл, java" />
	<meta name="author" content="Хей Лонг" /> 

	<style>
	
	body {
	background: white url(../web/exp/mphon07.jpg) no-repeat fixed right; /*_________Здесь девочка с фона*/
	background-size: contain;
	text-align:justify;
	font-size:20px;
	}

	li {color:blue; list-style-type:none;}

	a.slnk01 {font-size:20px; bold; text-decoration:none;}
	a.slnk01:link {color:fuchsia}
	a.slnk01:visited {color:green}
	a.slnk01:hover {color:orange}
	a.slnk01:active {color:red}

	h1 {text-align:center;}

	#mainc {position:absolute;
	background-color: white;
	left: 50px; top: 100px;
	width: 70%; /* ________________________Здесь ширина блока*/
	border: 3px outset fuchsia;
	margin-bottom: 200px;
	padding: 15px;
	}
	
	img {border:2px solid fuchsia}
	</style>

	<link rel="shortcut icon" href="../web/exp/ico1.ico">

	</head>
<!--████████████████████████████-->
<!--████████████████████████████-->
	<body>

<div id="mainc">

<p>Первый вариант создаётся по учебному материалу, содержащему много недоработок. Поэтому решил попробовать снова.
</p>

<a class="slnk01" href="../general.html">База конспектов.</a><br>
<a class="slnk01" href="jaba.html">Первый вариант конспекта.</a><br>

<a name="strt"><h1>Оглавление.</h1></a>

<ol>
<li><a class="slnk01" href="#chpt01">Запуск нового проекта.</a></li>
<li><a class="slnk01" href="#chpt02">Типы данных, операции.</a></li>
<li><a class="slnk01" href="#chpt03">Ввод.</a></li>
<li><a class="slnk01" href="#chpt04">Простые конструкции.</a></li>
<li><a class="slnk01" href="#chpt05">Массив.</a></li>
<li><a class="slnk01" href="#chpt06">Функция.</a></li>
<li><a class="slnk01" href="#chpt07">Класс.</a></li>
<li><a class="slnk01" href="#chpt08">Пакет.</a></li>
<li><a class="slnk01" href="#chpt09">Еттеры, иторы, аторы.</a></li>
<li><a class="slnk01" href="#chpt10">10</a></li>
<li><a class="slnk01" href="#chpt11">11</a></li>
<li><a class="slnk01" href="#chpt12">12</a></li>
<li><a class="slnk01" href="#chpt13">13</a></li>
<li><a class="slnk01" href="#endin">Вниз</a></li>
</ol>

<hr><!--████████████████████████████-->

<a name="chpt01">
<h1>Начало проекта.
</h1>
</a>

<p>Скачать немного джавы. Скачать Intellij IDEA. Настроить это. Создать первый класс в новом проекте. Выполнить его. Много инструкций, и мне уже лень это всё делать. Будем клепать таблицы.
</p>

<a class="slnk01" href="http://cybern.ru/make-project.html">Сайт из источника. Глава по созданию пустого проекта.</a><br>

<p>Наверное, повторять заново мне лень. Самые первые главы разобраны подробно в первом конспекте. Будем считать, что здесь рассказано про структуру простейшей программы, выводящей на консоль небольшой текст.
</p>

<hr><!--████████████████████████████-->

<a name="chpt02">
<h1>Глава 2. Типы данных, операции.</h1>
</a>

<table width="" border="">
<caption>Типы данных</caption>
<tr>
<th>Тип</th>
<th>Описание</th>
</tr>
<tr>
<td>boolean</td>
<td>Логический тип. Занимает 1 байт. По умолчанию false, также может принимать значение true.</td>
</tr>
<tr>
<td>byte</td>
<td>Числовой, как и несколько следующих −128..127, по умолчанию 0.</td>
</tr>
<tr>
<td>short</td>
<td>−32768..32767</td>
</tr>
<tr>
<td>int</td>
<td>-2147483648..2147483647</td>
</tr>
<tr>
<td>long</td>
<td>−9.2*(10^18)..9.2*(10^18)</td>
</tr>
<tr>
<td>float</td>
<td>Дробные числа −3.4*(10^38)..3.4*(10^38) 5.55f суффикс?</td>
</tr>
<tr>
<td>double</td>
<td>Дробные числа −1.8*(10^308)..1.8*(10^308)</td>
</tr>
<tr>
<td>char ''</td>
<td>16-битный символ Unicode. Его значение по умолчанию равно ‘\u0000’.</td>
</tr>
<tr>
<td>String ""</td>
<td>Строка. Указывать с большой буквы.</td>
</tr>
<tr>
<td>final int</td>
<td>Константа далее тип. Вероятно можно использовать разные.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>

<table width="" border="">
<caption>Операции</caption>
<tr>
<th>Операция</th>
<th>Описание</th>
</tr>
<tr>
<td>=</td>
<td>Присваивание.</td>
</tr>
<tr>
<td>+-*/</td>
<td>Вряд ли нуждается в комментариях.</td>
</tr>
<tr>
<td>%</td>
<td>Остаток от деления.</td>
</tr>
<tr>
<td>+= -= *=</td>
<td>(а +=1) == (a = a+1) Сокращённо присваивание с операцией над самой переменной.</td>
</tr>
<tr>
<td>++ --</td>
<td>Вроде как для целых увеличение или уменьшение на 1. (1*++х != 1*х++)</td>
</tr>
<tr>
<td>== !=</td>
<td>Возвращает логический результат сравнивания.</td>
</tr>
<tr>
<td>< <= > >=</td>
<td>Логический. Возвращает истину, если положение элемента раньше или позже подтверждается.</td>
</tr>
<tr>
<td>||</td>
<td>ИЛИ (дизъюнкция)</td>
</tr>
<tr>
<td>&&</td>
<td>И (Конъюнкция)</td>
</tr>
<tr>
<td>^</td>
<td>XOR (отрицание или)</td>
</tr>
<tr>
<td>!</td>
<td>Отрицание</td>
</tr>
<tr>
<td>>> << >>> & | ~</td>
<td>Некоторые побитовые операции, рассмотреть отдельно</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>

<img src="img2/logic01.jpg"><br>
<img src="img2/logic02.jpg"><br>

<table width="" border="">
<caption>Некоторые действия с символами и строками.</caption>
<tr>
<th width="25%">Действие</th>
<th>Описание</th>
</tr>
<tr>
<td>сhar a = (char) i;</td>
<td>Записывает в а символ под номером i.</td>
</tr>
<tr>
<td>int I = a.indexOf(b);</td>
<td>Запишет в I номер первого вхождения символа b в строке а. Нумерация с нуля.</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>Работает по тому же принципу, но возвращает номер последнего вхождения символа в строку.</td>
</tr>
<tr>
<td>char c = a.charAt(i);</td>
<td>Запишет в переменную c символ стоящий на i-м месте в строке a. (i>Na=error)</td>
</tr>
<tr>
<td>Int I = a.length();</td>
<td>Получить длину строки.</td>
</tr>
<tr>
<td>a1 = a2.replace(b1,  b2);</td>
<td>в а1 записывает а2, меняя каждый символ б1 на б2.</td>
</tr>
<tr>
<td>a1 = a1.replace(b1, b2);</td>
<td>Перезаписывает а1. Аналогично предыдущему.</td>
</tr>
<tr>
<td>a = a.toLowerCase();</td>
<td>Всё к нижнему регистру.</td>
</tr>
<tr>
<td>toUpperCase</td>
<td>К верхнему регистру.</td>
</tr>
<tr>
<td>a = a1.concat(a2);</td>
<td>То же, что и а1+а2</td>
</tr>
<tr>
<td>Int I = a1.compareTo(a2);</td>
<td>Запишет в I значение <0, если лексикографически a1 меньше a2, и >0 в обратном случае. Если же a1 лексикографически эквивалентна a2 то в I будет записано 0.</td>
</tr>
<tr>
<td>String a1 = a.substring(i);</td>
<td>Запишет в строку a1 всю ту часть строки a которая начинается с символа с номером i.</td>
</tr>
<tr>
<td>String a1 = a.substring(i, j);</td>
<td>Запишет в a1 часть строки a с символа с номером I и до символа с номером j (не включая j).</td>
</tr>
<tr>
<td>a.equals(b)</td>
<td>Сравнивает содержимое ссылочных переменных, логический.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>

<p>StringBuilder s = new StringBuilder("abcd"); это какой-то стандартный класс для работы со строкой с экономией памяти. Вероятно, при перезаписи одной строковой переменной в памяти всё равно создаётся новый объект. Работу класса раскроем позже.
</p>

<p style="color:blue">StringBuilder s = new StringBuilder("abcd");<br>
s.append('e');//abcde добавить в конец символ<br>
s.delete(1,2);//acde удаляет подстроку с i - го по j - ый символ<br>
s.insert(1,'b');//abcde вставляет на i - ое место объект j<br>
s.deleteCharAt(2);//abde<br>
String ans = s.toString() //чтобы вернуться от StringBuilder к String;
</p>


<hr><!--████████████████████████████-->

<a name="chpt03">
<h1>Глава 3. Ввод.</h1>
</a>

<p style="color:blue">import java.util.Scanner;<br>
public class test <br>
{<br>
public static void main(String[] args)<br>
{<br>
Scanner vvod = new Scanner(System.in);<br>
int a = vvod.nextInt();//считываем целое число a<br>
int b = vvod.nextInt();//считываем целое число b<br>
System.out.print(a+b);//выводим сумму a+b<br>
}<br>
}
</p>

<p>Подключаем что-то из первой строки. Создаём объект vvod типа сканер, можно с иным названием. Присваиваем переменным значения, вызвав объект с подфункцией перевода к целочисленному типу. Выводим их сумму. Конструкция выглядит сложной, и по первому источнику, она не единственная, поэтому интересно бы узнать элементарные фрагменты языка, а потом учить наработанные библиотеки вековых трудов. Но это как-нибудь в процессе. Эту главу наверняка придётся модифицировать. Пока просто скину текст из первого источника.
</p>

<p style="color:blue">InputStream inputStream = System.in;<br>
Reader inputStreamReader = new InputStreamReader(inputStream);<br>
BufferedReader bufferedReader = new BufferedReader(inputStreamReader);<br>
String name = bufferedReader.readLine(); //читаем строку с клавиатуры<br>
String sAge = bufferedReader.readLine(); //читаем строку с клавиатуры<br>
int nAge = Integer.parseInt(sAge); //преобразовываем строку в число.
</p>

<p>Более компактная запись первой части:
</p>

<p style="color:blue">BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));<br>
String name = reader.readLine();<br>
String sAge = reader.readLine();<br>
int nAge = Integer.parseInt(sAge);
</p>

<p>Еще более компактная, уже использованная выше:
</p>

<p style="color:blue">Scanner scanner = new Scanner(System.in);<br>
String name = scanner.nextLine();<br>
int age = scanner.nextInt();
</p>

<p>
</p>



<hr><!--████████████████████████████-->

<a name="chpt04">
<h1>Глава 4. Простые конструкции.</h1>
</a>

<p>Условный оператор if.
</p>

<p style="color:blue">        if ( x > 100)<br>
        {<br>
            x=x-100;<br>
            System.out.println ("Вычтем сотку - "+ x );<br>
        }<br>
        else<br>
            System.out.println ("Меньше сотки. Ну и лан.");
</p>

<p>Всё довольно просто. Условие ставится в скобку, внутри считаются логические операции. Одну операцию можно ставить без фигурных скобок. Использование иного случая необязательное, это приблизительно полный пример.
</p>

<p>Как это там называлось... Условный оператор вариантов, как-то так? Case.
</p>

<p style="color:blue">switch (x)<br>
{<br>
  case значение1 : операторы1 ;<br>
  case значение2 : операторы2 ;<br>
  case значение n : операторы n ;<br>
  default: операторыПоУмолчанию ;<br>
}
</p>

<p>Здесь тоже нехитро. В случае совпадения х с вариантами выполняется соответствующее дествие. Есть ещё оператор break;, но его предназначение мутное. Ведь выполняться и так должны только те варианты, отвечающие логике. апд Оказывается, есть случаи, когда х равен нескольким кейсам. Тогда брейк завершает выполнение свитча. Или возможны ещё варианты, что кейсы могут выполняться по очереди. Или это способ быстрого выхода для экономии ресурса. Брейк можно ставить после каждого кейса, кроме по умолчанию.
</p>

<p>Составной оператор -- даже можно было не упоминать, хотя один нюанс повторить стоит. Если нужно логически фрагмент кода соединить в одну последовательность, напирмер в результате работы условного оператора, то соединяем его фигурными скобками {}. Внутри можно объявить новые переменные, и они будут существовать только внутри фрагмента. Имена со внешними переменными совпадать не должны.
</p>

<p>Цикл  со счётчиком.
</p>

<p style="color:blue">for (int i = 0; i < 5; i++) {};
</p>

<p>Блок инициализации. Проверка условия. Если оно истинно, выполняется одиночный или составной оператор. За ним блок приращения. Когда условие станет ложным, код больше не выполнится. В данном примере код выполнится пять раз.
</p>

<p>Цикл с предусловием. Так они в паскале назывались, а тут слишком близко.
</p>

<p style="color:blue">while (a < b) a *= 2;
</p>

<p>Проверяет условие и затем выполняет нужные действия.
</p>

<p>Комментарии на скрине будут.
</p>

<img src="img2/6.png"><br>

<p>Простой условный оператор. int c = a > b ? 1 : 0; Если выполняется a>b, то с=1, иначе с=0.
</p>

<p>
</p>

<p>
</p>


<hr><!--████████████████████████████-->

<a name="chpt05">
<h1>Глава 5. Массив.</h1>
</a>

<p style="color:blue">int[] a; char[] c;<br>
a= new int[10]; c= new chr[10]; //выделение памяти<br>
int x= new int[5]{1,2,3,4,5}; //сразу инициализировать
</p>

<p>Ниже пример кода. Сначала ввести количество элементов, создать массив целых чисел количества n. Затем, n раз, от 0 до n-1 элемента заполняем каждый их них значением.
</p>

<p style="color:blue">import java.util.Scanner;<br>
public class test {<br>
    public static void main(String[] args) {<br>
        int[] a;//массив целых чисел<br>
        int n;//количество элементов в массиве<br>
        Scanner in = new Scanner(System.in);<br>
        n = in.nextInt();<br>
        a = new int[n];<br>
        for(int i = 0; i < n; i++)<br>
        {<br>
            a[i] = in.nextInt();<br>
        }<br>
    }<br>
}
</p>

<p>Добавим фрагмент для модификации массива, затем вывода его. Добавить бы ещё немного поясняющих операторов вывода, для наглядного примера готовой программы, но это потом.
</p>

<p style="color:blue">for(int i = 0; i < a.length; i++)<br>
{<br>
    a[i] = a[i] * 2;<br>
}<br>
for(int i = 0; i < a.length; i++)<br>
{<br>
    System.out.println(a[i]);<br>
}
</p>

<p>Вот и первая картиночка. Код откомпилирован и весь рабочий.
</p>

<img src="img2/1.png"><br>

<p>Можно обращаться к элементам массива по индексу. a[3]=5;
</p>

<p>Двумерный массив. Чтобы работать с его элементами, надо объявить не только его, но и содержащиеся одномерные массивы. Сказано в источнике.
</p>

<p style="color:blue">int[][] a = new int[3][3]; <br>
for(int i = 0; i < a.length; i++) { a[i] = new int[3]; } // этот вот самый момент<br>
a[0][0] = 1;
</p>

<hr><!--████████████████████████████-->
<a name="chpt06">
<h1>Глава 6. Функция, метод.</h1>
</a>

<p style="color:blue">public static int pow(int a, int b) {<br>
        int result = 1;<br>
        for (int i = 0; i < b; i++) {<br>
            result *= a;<br>
        }<br>
        return result;<br>
    }
</p>

<p>Этот метод принимает два числа. Цикл оборачивает первое умножением само на себя количеством раз, соответствующим второму. То бишь возведение a в степень b. Модификаторы public static подобно основному методу main. Вызывать метод можно отовсюду, вернёт он целое значение из result.
</p>

<p>Массивы могут участвовать в качестве аргумента и возвращаемого объекта.
</p>

<img src="img2/2.png"><br>

<p>Рексурсию понять сложно, но со временем реально. Стандартный пример с факториалами.
</p>

<p style="color:blue">public static int factorial(int n) {<br>
    if(n==0)<br>
        return 1;<br>
    return n*factorial(n-1);<br>
}
</p>

<p>Я понял рекурсию как закручивающуюся спираль. Там ведь есть условие, и когда оно сработает в последний раз, спираль развернётся. Если воспринять факториал как выбранное повторяющееся действие между всеми элементами динамического ряда от х1 до х2, то это выглядит уже не так просто. Надо будет скомпилировать такой вариант.
</p>

<hr><!--████████████████████████████-->
<a name="chpt07">
<h1>Глава 7. Класс, объект.</h1>
</a>

<p>Основа программы - основной класс, именем совпадающий с java-файлом, также содержащий основной метод main. Момент этики - camel-style, предполагающий имена классов с большой буквы, а имена полей (переменных класса) и методов класса с маленькой.
</p>

<p>Классы представляют собой сложные, составные типы данных, набор переменных. Например, человека можно для конкретной цели описать именем, возрастом и ещё чем-либо. Затем создавать объекты человеческого типа данных.
</p>

<p style="color:blue">public class User1 {<br>
    int age;//поле<br>
    String fName;//поле<br>
    String lName;//поле<br>
    String say() {//метод<br>
            return "I am "+fName+" "+lName;<br>
    }<br>
}
</p>

<p>Переменная назначается обычным способом. User1 us1; Отличие в том, что примитивные переменные хранят значение, и операции с ними сразу меняют его. Переменные сложного типа хранят только ссылку на класс. Чтобы создать объект этого класса, используется new.
</p>

<p style="color:blue">User1 us1 = new User1();<br>
us1.age = 25;<br>
us1.fName = "Vasilii";<br>
us1.lName = "Vasechkin";
</p>

<p>В остальном всё примерно так, как уже было обозначено, функционал тот же.
</p>

<p>Про ссылочные типы есть непонятные моменты. Литералы -- некие константы, используемые в операциях. Сравнение двух ссылочных переменных, не имеющих общего адреса, хоть и ссылающихся на одинаковые значения, покажет их неравенство. На примере строк, являющихся сложными переменными. 
</p>

<p style="color:blue">String s1 = "abc", s2 = "abc"; boolean x;<br>
x= s1 == s2 // false, адреса значений переменных разные<br>
x= s1 == "abc" // true, происходит конкатенация (?), и литерал abc сравнивается уже со значением через адрес s1.
</p>

<p>Хотя если вдуматься, всё вроде ясно. Другой момент, если переменная со ссылкой не есть сам объект, то где он находится и что с ним делать?
</p>

<p>Переменная хранит адрес на объект. Если адреса нет, то объект должен уничтожиться.
</p>

<p>Конструкторы класса позволяют создать вариант объекта, сразу вызвав его с заданными значениями. Это методы, сразу принимающие значения и передающие их в поля класса. Имя как у класса. По умолчанию конструктор присутствует, но не работает, не имеет параметров. Для одного класса можно задать несколько конструкторов, а при создании объекта соответствием набору агрументов будет использован один из них. Один пример.
</p>

<img src="img2/3.png"><br>

<p>Здесь в коде есть создание класса с конструктором. Ещё один момент -- если присутствует один пользовательский конструктор, то по умолчанию конструктор нужно создавать дополнительно, или запись без параметров будет ошибкой.
</p>

<p style="color:blue">Chel hren = new Chel(); //ошибка, конструктор по умолчанию отсутствует.
</p>

<p>Все классы в Java считаются унаследованными от класса Object и содержат копию его методов.
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<hr><!--████████████████████████████-->
<a name="chpt08">
<h1>Глава 8. Пакеты.</h1>
</a>

<p>Файлы в компьютере группируются по папкам. Классы в Java (а каждый класс лежит в отдельном файле) группируются по пакетам, которые являются папками на диске. Ничего принципиально нового. «Полным уникальным именем класса» является «имя пакета» + «имя класса». Полное имя класса всегда уникально.
</p>

<p>Каждый раз писать длинное имя, например java.util.ArrayList, очень неудобно. Поэтому в Java добавили возможность «импортировать классы». В своем коде ты можешь пользоваться коротким именем других классов, но ты должен в начале своего класса явно указать, какой именно класс будет использоваться. Делается это конструкцией вида import java.util.ArrayList;
</p>

<p>В разных пакетах могут лежать классы с одинаковыми именами. Но мы не можем импортировать в наш класс два класса с одинаковыми именами, поэтому к одному из них придётся обращаться по полному имени.
</p>

<p>Лучше всегда класть классы в пакеты, а не в корень папки src. Когда классов мало, это ещё не представляет проблему, но когда классов много – очень легко запутаться. Поэтому всегда создавай классы только в пакетах. В Java принято давать классам и пакетам осмысленные имена. Многие компании выпускают свои библиотеки (набор классов) и, чтобы не было путаницы, называют пакеты этих классов по имени компании/сайта.
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<hr><!--████████████████████████████-->
<a name="chpt09">
<h1>Глава 9. Этика функционала. </h1>
</a>

<p>Чем отличается гуманитарий от технаря? Задача первых -- копошиться в грязи собственной деятельности. Хотя это тоже полезно, но... Вторые видят принципы, механику, суть всего. Поэтому подмена понятий может разрушить мир таких людей. Стоит сразу объяснять, что есть закон, а что -- условность времени и места. Но это неуместная философия, а глава посвящена методам, которые имеют свои задачи, хотя их необходимость весьма условна.
</p>

<p>Коснтрукторы упомянуты в позапрошлой главе. Их задача -- создать объект класса с введёнными полями данных. Конструкор по умолчанию есть в каждом классе, поэтому вызов класса без аргументов работает так, как работает. Если создать один пользовательский конструктор, то создание объекта с несоответствующим набором параметров приведёт к ошибке компилятора. Поэтому, наверное, стоит делать два конструктора, чтобы один пользовательский дублировал конструктор по умолчанию. Зависит от ситуации и задач класса.
</p>

<p>Геттеры и сеттеры. Это методы, возвращающие или модифицирующие значение поля класса. Если можно обратиться к ним напрямую, пока неясно, зачем нужен метод. Например, у класса Chel поле name. Берём объект chl01 класса Chel, и делаем chl01.name=Lola. Потом таким же образом взаимодействуем с Лолой. А тут вдруг потребовался метод класса Chel. Метод GetName возвращает name объекта, пишется вручную. Метод SetName принимает значение, передаёт его в параметр name, и затем делает this.name=name. Думаю, что даже имена методов можно изменить, суть исключительно в том, чтобы они давали то, что дают. осталось понять, в каких случаях без них не обойтись. Ниже текст из источника.
</p>

<img src="img2/4.png"><br>

<p>В Java принято скрывать переменные от доступа из других классов. Обычно переменные, объявленные внутри классов, имеют модификатор private.
Чтобы другие классы могли менять значения таких переменных, для каждой из них создается пара методов: get и set. Задача метода get вернуть текущее значение переменной тому, кто его вызвал. Задача метода set установить новое значение переменной.
Если мы не хотим, чтобы кто-то менял значения переменных наших объектов, мы можем просто не писать метод set для него, или сделать его private. Также в этот метод можно добавить дополнительные проверки данных. И если переданное новое значение неверно, то ничего не менять.
Т.к. переменных в классе может быть много, то методы get и set обычно имеют в своем имени имя той переменной, с которой работают.
Если переменная называется name, то методы setName и getName. И т.д. по аналогии.
</p>

<p>Теперь экранирование. Здесь ближе к полезным технологиям, и эту тему можно будет раскрыть прямо тут. Потом.
</p>

<img src="img2/5.png"><br>

<p>Теперь инициализаторы. Есть объекты, существование которых предполагает обязательное наличие данных. Например, есть люди без имени и адреса, но у них есть масса и объём. Это логично. Метод initialize принимает параметры, которые должны определить, существует ли объект, и в каком статусе. Наверное. Если с объектом работать нельзя, его называют невалидным (invalid), если можно – валидным (valid). Основная задача метода initialize – передать в объект все необходимые данные, чтобы сделать его валидным. Имя метода тоже условное, я думаю.
</p>
<!-- 6 скрин в разделе простых конструкций -->
<img src="img2/7.png"><br>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<hr><!--████████████████████████████-->
<a name="chpt10">
<h1>Глава 10. </h1>
</a>

<hr><!--████████████████████████████-->
<a name="chpt11">
<h1>Глава 11. </h1>
</a>

<hr><!--████████████████████████████-->
<a name="chpt12">
<h1>Глава 12. </h1>
</a>

<hr><!--████████████████████████████-->
<a name="chpt13">
<h1>Глава 13. </h1>
</a>

<hr><!--████████████████████████████-->
<a href="#strt" name="endin">В начало документа.</a><br>
<a href="http://cybern.ru/" name="1doc">Источник обучения.</a><br>
</div>

	</body>
<!--████████████████████████████-->
<!--████████████████████████████████████████████████████████-->
	</html>

<!--

 style="color:blue"
<img src="img/1.png"><br>
&lt открывающий тег
&gt; закрывающий тег

<> &lt;&gt;
<></> &lt;&gt;&lt;/&gt;
</> &lt;/&gt;

<pre></pre>

<p>
</p> абзац
<h1></h1>
<h2></h2>
<h3></h3>
<h4></h4>
<h5></h5>
<h6></h6>

-->
<!--████████████████████████████████████████████████████████████████████████████████████-->