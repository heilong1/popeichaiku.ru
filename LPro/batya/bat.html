<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--████████████████████████████████████████████████████████████████████████████████████-->
	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--████████████████████████████████████████████████████████-->
<!--████████████████████████████-->
	<head>

	<title>Конспект Batch</title>

	<meta http-equip="Content-Type" content="text/html" charset="UTF-8" />
	<meta name="description" content="обучающий проект, главная" />
	<meta name="keywords" content="ключ, обучение, хтмл, паскаль" />
	<meta name="author" content="Хей Лонг" /> 

	<script src="exp/scr1.js" type="text/javascript">
	</script>

	<style>
	
	body {
	background: white url(../web/exp/mphon02.jpg) no-repeat fixed right;
	background-size: contain;
	text-align:justify;
	font-size:20px;
	}

	li {color:blue; list-style-type:none;}

	a.slnk01 {font-size:20px; bold; text-decoration:none;}
	a.slnk01:link {color:fuchsia}
	a.slnk01:visited {color:green}
	a.slnk01:hover {color:orange}
	a.slnk01:active {color:red}

	h1 {text-align:center;}

	#mainc {position:absolute;
	background-color: white;
	left: 100px; top: 100px;
	width: 60%;
	border: 3px outset fuchsia;
	margin-bottom: 200px;
	padding: 15px;
	}
	</style>

	<link rel="shortcut icon" href="../web/exp/ico1.ico">

	</head>
<!--████████████████████████████-->
<!--████████████████████████████-->
	<body>

<div id="mainc">

<p>Конспект электронного хакактера, содержащий материалы для обучения написанию батников. Страница обновляется по мере изучения материала, версии сохраняться не будут. Интерфейс забран у предыдущего проекта, ибо показался более привлекательным.
</p>
<a href="../general.html">База конспектов.</a><br>

<a name="strt"><h1>Оглавление.</h1></a>

<ol>
<li><a class="slnk01" href="#chpt01">Как сделать первый батник.</a></li>
<li><a class="slnk01" href="#chpt02">Переменные, ввод-вывод.</a></li>
<li><a class="slnk01" href="#chpt03">Некие простые конструкции.</a></li>
<li><a class="slnk01" href="#chpt04">Интерфейс и внешние эффекты.</a></li>
<li><a class="slnk01" href="#chpt05">Основы работы в системе.</a></li>
<li><a class="slnk01" href="#chpt06">123</a></li>
<li><a class="slnk01" href="#chpt07">123</a></li>
<li><a class="slnk01" href="#chpt08">123</a></li>
<li><a class="slnk01" href="#chpt09">123</a></li>
<li><a class="slnk01" href="#chpt10">123</a></li>
<li><a class="slnk01" href="#endin">В конец документа.</a></li>
</ol>

<hr><!--████████████████████████████-->

<a name="chpt01">
<h1>Глава 1. Первый батник.
</h1>
</a>

<p>Файл с расширением bat или cmd открывается через оболочку командной строки. Редактируется любым текстовым редактором. Содержит команды, которые влияют на происходящее в операционной системе.
</p>

<p>Создадим в корневом каталоге С:\ файл 123.bat и напишем следующий текст:
</p>

<p style="color:blue">@rem My First Batch file!<br>
@echo off<br>
echo Three<br>
echo Two<br>
echo One<br>
echo Hello World!<br>
pause<br>
</p>

<p>Запустим полученный файл и увидим окно с результатом. Также можно запустить файл из командной строки. Нажмём комбинацию Win + R, вводим cmd и подтверждаем. Затем выбираем директорию, и набираем имя файла.
</p>

<img src="img/001.png"><br>

<p>Rem комментарий. Срока игнорируется компиляторами. Echo off выключает режим отображения выполняемых команд перед результатом их выполнения. echo выводит текст на экран. pause останавливает программу до действия пользователя.
</p>

<p>
</p>

<p>
</p>

<hr><!--████████████████████████████-->

<a name="chpt02">
<h1>Глава 2. Переменные, ввод-вывод.</h1>
</a>

<p>Переменные задаются через команду set. По умолчанию это будет строковая переменная, записавшая все символы до конца строки после знака =, включая пробелы, а перед ним не должно быть пробела, у меня из-за него случился долгий поиск причины глюков. Чтобы принять число, нужно использовать set /A. Вызвать переменную можно, заключив её в знаки %.
</p>

<p style="color:blue">@echo off<br>
set name1=Ivan<br>
set /A age1 = 20 + 5<br>
set info1=%name1% Ivanov, %age1% years old.<br>
echo %info1%<br>
pause
</p>

<img src="img/002.png"><br>

<p>Второй вид переменных Arguments variable передаётся в файл. Вероятно, это работает только из командной строки или прочих текстовых консолей. Всего таких пеерменных в одном батнике может быть только десять. Вызов через %0 -- %9. %0 содержит имя файла с директорией в случае указания её. Например, если вызвать 123.bat failik, то %0 будет содержать 123.bat, или же если открыть файл из файловой среды ОС, то C:/123.bat, а %1 будет строкой failik. Если вывод %1 присутствует, но не передан в файл, то отображается информация об использовании echo off. Вероятно, тут есть правило генерации переменных, узнаю позже.
</p>

<p>Команда SHIFT сдвигает переменные к нулю, то бишь нулевая переменная утрачивается окончательно, а первая записывается в нулевую, и подобно этому со следующими.
</p>

<p>chcp 1251 позволяет использовать кириллицу в командах вывода или переменных. Вызывает строку с указанием применённой кодировки, но почему-то не работает пока у меня, хотя уведомления русские. 65001 кодировка помогла, но язык уведомлений интерфейса стал наоборот английским.
</p>

<p>Ввод строковой переменной set /p var1=, затем вывод echo %var1%.
</p>

<p>Переменые, созданные в батнике во время сессии запущенной комендной строки, остаются доступными для других батников. Например, при совпадении имён? Надо проверить. Однако, если назначить блок программы между строчками setlocal и endlocal, все созданные там переменные не будут существовать вне блока. Для оптимизации памяти.
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>



<hr><!--████████████████████████████-->

<a name="chpt03">
<h1>Глава 3. Некие простые конструкции.</h1>
</a>

<p>Пример использования If и Goto.
</p>

<p style="color:blue">@echo off<br>
echo press 1 or 2<br>
set /p option=<br>
if '%option%'=='1' goto :label1<br>
if '%option%'=='2' start 123.jpg<br>
:label1<br>
echo hi its label1<br>
pause
</p>

<p>Предлагает нажать 1 или 2. Вводим строковую переменную. Сравниваем её логически с символом 1 или 2, и в первом случае goto переводит на метку с соответствующим именем. Вариант 2 открывает картинку, но после этого также перейдёт к действиям после метки. Несовершенная конструкция.
</p>

<p>
</p>

<p>
</p>

<hr><!--████████████████████████████-->

<a name="chpt04">
<h1>Глава 4. Интерфейс и внешние эффекты.</h1>
</a>

<p>Msg * Текст выводит уведомление в ОС с указанным текстом в небольшом окне.
</p>

<p>cls очищает экран командной строки.
</p>

<p>start путь файла или файл в директории -- запускает файл в стандартном приложении. 
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>Переменные среды системы позволяют добавлять некоторые общие переменные для командной строки.
</p>


<hr><!--████████████████████████████-->

<a name="chpt05">
<h1>Глава 5. Работа в системе.</h1>
</a>

<img src="img/003.png"><br>
<img src="img/004.png"><br>
<img src="img/005.png"><br>


<p>Условный опера
</p>

<p style="color:blue">if a>b<br>
then writeln(a,' большее из них.')<br>
else writeln(a,' не большее из них. могут быть равны.');
</p>



<img src="img/8.png"><br>



<hr><!--████████████████████████████-->

<a name="chpt06">
<h1>Глава 6. Циклы.</h1>
</a>

<p style="color:blue">for x:=1 to 50 do<br>
begin<br>
write (x,' ')<br>
end;<br>
for x:=50 downto 1 do<br>
begin<br>
write (x,' ')<br>
end;
</p>

<p>Здесь переменная х выступает в роли счетчика цикла. Счетчик может быть только порядкового типа. То бишь он определит своё прошлое и следующее значение. Вещественные числа не подходят определённо. Символьные и булевские подойдут, но используются редко, куда удобнее целочисленные. Телом цикла может быть оператор простой либо составной. Нельзя переопределить значение счетчика, чтобы повлиять на ход цикла, но можно использовать для определения других переменных. По окончании счетчик автоматически прибавит единицу. Тело цикла будет совершено в последний раз, когда счетчик равен конечному значению.
</p>

<p style="color:blue">repeat {тело} until {условие};
</p>

<p>Тело может быть одним или несколькими операторами. begin end использовать здесь не обязательно. Цикл будет произведён минимум один раз, затем будет постпроверка условия. В случае истинности цикл будет завершён.
</p>

<p style="color:blue">while {условие} do {тело};
</p>

<p>Проверка выполняется вначале. Если условие ложно, цикл не будет выполнен. Если истинно, то будет выполняться. Тело включает простой или составной оператор. Ещё одна задачка для ума. Любое введенное число нужно разложить на простые множители. Простые - делятся только на себя и на единицу. Любое сложное число можно выразить произведением простых. Примерный алгоритм для числа 100.<br>
100/2=50. делится нацело на 2 - первый множитель.<br>
50/2=25.<br>
25/2♦25/3♦25/4♦25/5=5. делить на 4 глупо, потому что 25 тогда разделилось бы и на 2. Но иначе никак.<br>
5/2♦5/3♦5/4♦5/5=1.
</p>

<img src="img/10.png"><br>

<p>Нет времени объяснять. Программа работает, и то ладно. Вникать в мелочи долго.
</p>

<hr><!--████████████████████████████-->

<a name="chpt07">
<h1>Глава 7. Генератор псевдослучайностей.</h1>
</a>

<p>Команда randomize; инициализирует генератор. Функция random(X) возвращает любое число в интервале 0..Х-1. Например, n:=random(10) присвоит n значение 0..9. Разрешена такая примочка - n:=(random(10)+1); Глава короткая, но интересная. Этот псевдогенератор не идеален, поэтому стоит поискать расширенные способы.
</p>

<hr><!--████████████████████████████-->

<a name="chpt08">
<h1>Глава 8. Символы, строки.</h1>
</a>

<p>American standard code for information interchange, ASCII. В текстовом редакторе компилятора видны не все символы. Но основные объяснить можно. Во многих стандартных редакторах можно написать символ, удерживая alt и набирая код. Есть специфичные символы вроде 10 - он не отображается, но обозначает перевод строки. Суть символа в том, чтобы графически отображать информацию. Для других операций символы бесполезны. Всего в таблице их 255. Нулевой и 256-й не выводятся. При продолжении нумерации будет простой повтор.
</p>

<img src="img/14.png"><br>

<p>Переменные символы, точнее символьные переменные, в разделе объявления имеют тип char. Символьные константы указываются в 'таких скобках'. ch:='5'; Предыдущая запись гласит, что переменная ch получила значение 5, вот только эта пятёрка не будет полезной для арифметических операций - она символ.
</p>

<p>Символьные константы можно сравнивать. При этом будет использован ASCII-код.
</p>

<p>x:char; x:=chr(170); x='к'. Это функция chr(), она из кода возвращает символ.
</p>

<p>x:integer; x:=ord('к'); x=170. Это функция ord(), она из символа возвращает код.
</p>

<p>Строковые переменные объявляются s:string[X]; Х является ограничением количества символов, и не является обязательным пунктом переменной, по умолчанию имеющей максимальную длину 255 символов. Присваивание такое - str:='слово'; Сложение строковых переменных подобно числовым - последовательное соединение. Складывать строковые переменные со строковыми константами также возможно, используя известные скобки.
</p>

<p>Х[5] представляет собой обращение к пятому символу в строковой переменной. chr01:=strk[1];
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>chr(x)</td>
<td>возвращает символ из номера</td>
</tr>
<tr>
<td>ord(ch)</td>
<td>возвращает номериз символа</td>
</tr>
<tr>
<td>length(s)</td>
<td>возвращает длину строковой переменной</td>
</tr>
<tr>
<td>copy(s,n,l)</td>
<td>из строки S копирует L символов, начиная с N</td>
</tr>
<tr>
<td>delete(s,n,l)</td>
<td>из строки S удаляет L символов, начиная с N</td>
</tr>
<tr>
<td>readkey</td>
<td>считывает нажатый символ</td>
</tr>
<tr>
<td>keypressed</td>
<td>определяет факт нажатия. неуместно, но пусть тут.</td>
</tr>
</table>


<hr><!--████████████████████████████-->

<a name="chpt09">
<h1>Глава 9. Массивы.</h1>
</a>

<p>X: array[1..10] of integer;
</p>

<p>1..10 - границы массива. Допускается для границ использовать любые порядковые значения, даже символьные. Нижняя позиция должна быть меньше верхней. На одну переменную есть ограничение памяти 64 КБ - учесть для объёмных массивов. Элементы массива могут быть символьными или булевскими, при должном типе.
</p>

<p>При вдумчивом изучении натолкнулся на бред. x:array['b'..'f'] of char=('2','4','Z','8','0');<br>
Отсюда следует, что x['d']=Z. По сути логично, но зачем... При заведении цикла счётчик приходится делать символом. Путает только. Символьная константа играет роль элемента массива, который может равняться любому другому значению другого типа.
</p>

<p>Назначение при объявлении. str:array[1..3] of string=('кто','где','как');
</p>

<p>Wm: array[1..5,1..5] of integer; Это двумерный массив. 5х5, вроде таблицы. Ниже примерный и бесполезный код использования двумерного массива.
</p>

<img src="img/11.png"><br>

<p>Довольно ёмкий материал - сортировка массивов. Ради забавы попробовал сам смастерить - но только сломал мозг.
</p>

<img src="img/16.png"><br>

<p>Разобраться с этим можно позднее. Изучить и понять.
</p>

<p>Есть ещё способы сортировки по невозрастающему убыванию вверх, и в другие стороны.. И ещё много применений для двумерных массивов. Раздел будет дополняться при необходимости.
</p>

<hr><!--████████████████████████████-->

<a name="chpt10">
<h1>Глава 10. Процедуры и функции.</h1>
</a>

<p>Всё просто. Скриншот с кодом, и разъяснение.
</p>

<img src="img/15.png"><br>

<p>Функции объявляются в соответствующем разделе. Имеют имя, тип своего значения, формальные параметры. Собственные разделы, переменные и тело функции. Переменные и константы, указанные в функции, используются только в ней, поэтому имена можно дублировать с внешними. Друг на друга они не влияют. За исключением формальных параметров функции - они тоже могут взять имя, использованное во внешнем теле, а значение они принимают именно из фактических параметров при обращении к функции.
</p>

<p>На конкретном коде - переменной х мы хотим придать значение операций, проведённых с ней. Вызываем функцию с этими операциями, сообщив параметр х. Значение фактического параметра х передаётся формальному параметру а внутри функции (можно было формальный параметр тоже назвать х). Внутри функции есть переменная z. Производятся необходимые операции, ввод-вывод, устойчивая часть программы. Обязательным условием является присвоение функции некоторого значения -- оно и будет возвращено вызывающей переменной, здесь результатом мы увидим 50. Существуют и нулевые функции, без формальных параметров и возврата значения, но условие нужно соблюсти - хотя бы присвоить функции значение 0. Вызвать функцию простым названием (fucsia), увидеть её работу и двигаться дальше.
</p>

<p>Процедуры. Несколько стандартных.
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>delay(ms)</td>
<td>задержка времени милисекунды</td>
</tr>
<tr>
<td>exit</td>
<td>завершает текущую структуру</td>
</tr>
<tr>
<td>halt</td>
<td>завершает работу приложения</td>
</tr>
<tr>
<td>gotoxy(x,y)</td>
<td>перевод курсора в Х,У</td>
</tr>
<tr>
<td>str(x,s)</td>
<td>перевод числа в строку</td>
</tr>
<tr>
<td>val(s,x,n)</td>
<td>перевод строки в число. n=0, либо порядок символа, вызвавшего сбой</td>
</tr>
</table>

<p>Пользовательские процедуры немного сложнее в плане количества особенностей.
</p>

<img src="img/17.png"><br>

<p>При имени процедуры указываются формальные параметры. И даже тут они делятся на два типа. Первый -- параметр-значение (a,b). Они принимают значение фактического параметра, константу, выражение. Если соотвествует переменная, в ходе работы процедуры она во внешней структуре не изменится, изменения останутся внутри процедуры, даже если имена переменных будут одинаковыми. Второй тип в этом отличается. Параметр-переменная (c) принимает адрес фактической переменной в памяти, и изменения коснутся её. То бишь, при вызове функции соответствующий фактический параметр должен быть только переменной. Естественно, всегда нужно учитывать количество и порядок фактических параметров при вызове. В процедуре можно использовать переменные локальные (m,n) и глобальные (abc). Локальные могут именами совпадать с переменными во внешней программе, но значения у них сохранятся внутри своих структур раздельно. Глобальные переменные описаны во внешней структуре, и изменятся при операциях с ними внутри процедуры.
</p>

<p>Если во внешней системе были переменные a,b,m,n, то после выполнения процедуры они останутся прежними. Вывести их в процедуре -- увидим локальные значения. Вывести во внешней -- увидим предыдущие. Но если они переданы в параметр-переменную (c), или не описаны как локальные, то будут изменены глобально.
</p>

<img src="img/18.png"><br>

<p>Процедуры и функции могут вызывать себя и себе подобных изнутри. А ещё они могут вызывать самих себя. Довольно трудно найти проблему, решение которой будет затрагивать этот способ, но это реально. Выше -- пример, программа вычисляет вещественное a в целой положительной степени n. Задействована рекурсия - обращение к самой себе. При желании можно попробовать проанализировать ход действия программы.
</p>

<hr><!--████████████████████████████-->

<a href="tp7konsp2c.html">Вторая часть.</a><br>

<hr><!--████████████████████████████-->

<a href="#strt" name="endin">В начало документа.</a><br>
</div>

	</body>
<!--████████████████████████████-->
<!--████████████████████████████████████████████████████████-->
	</html>

<!--

 style="color:blue"
<img src="img/1.png"><br>
&lt открывающий тег
&gt; закрывающий тег

<> &lt;&gt;
<></> &lt;&gt;&lt;/&gt;
</> &lt;/&gt;

<pre></pre>

<p>
</p> абзац
<h1></h1>
<h2></h2>
<h3></h3>
<h4></h4>
<h5></h5>
<h6></h6>

-->
<!--████████████████████████████████████████████████████████████████████████████████████-->