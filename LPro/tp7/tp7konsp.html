<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--████████████████████████████████████████████████████████████████████████████████████-->
	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--████████████████████████████████████████████████████████-->
<!--████████████████████████████-->
	<head>

	<title>Конспект Pascal</title>

	<meta http-equip="Content-Type" content="text/html" charset="UTF-8" />
	<meta name="description" content="обучающий проект, главная" />
	<meta name="keywords" content="ключ, обучение, хтмл, паскаль" />
	<meta name="author" content="Хей Лонг" /> 

	<script src="exp/scr1.js" type="text/javascript">
	</script>

	<style>
	
	body {
	background: white url(../web/exp/mphon02.jpg) no-repeat fixed right;
	background-size: contain;
	text-align:justify;
	font-size:20px;
	}

	li {color:blue; list-style-type:none;}

	a.slnk01 {font-size:20px; bold; text-decoration:none;}
	a.slnk01:link {color:fuchsia}
	a.slnk01:visited {color:green}
	a.slnk01:hover {color:orange}
	a.slnk01:active {color:red}

	h1 {text-align:center;}

	#mainc {position:absolute;
	background-color: white;
	left: 100px; top: 100px;
	width: 60%;
	border: 3px outset fuchsia;
	margin-bottom: 200px;
	padding: 15px;
	}
	</style>

	<link rel="shortcut icon" href="../web/exp/ico1.ico">

	</head>
<!--████████████████████████████-->
<!--████████████████████████████-->
	<body>

<div id="mainc">

<p>Конспект электронного хакактера, содержащий материалы для обучения программированию в среде Pascal. Страница обновляется по мере изучения материала, версии сохраняться не будут. Интерфейс забран у предыдущего проекта, ибо показался более привлекательным.
</p>
<a href="../general.html">База конспектов.</a><br>
<a href="tp7konsp2c.html">Вторая часть.</a><br>

<a name="strt"><h1>Оглавление.</h1></a>

<ol>
<li><a class="slnk01" href="#chpt01">Структура программы.</a></li>
<li><a class="slnk01" href="#chpt02">Практика, ввод-вывод.</a></li>
<li><a class="slnk01" href="#chpt03">Таблицы цветов, типов.</a></li>
<li><a class="slnk01" href="#chpt04">Операции, комментарии.</a></li>
<li><a class="slnk01" href="#chpt05">Условные операторы и безусловный переход.</a></li>
<li><a class="slnk01" href="#chpt06">Циклы.</a></li>
<li><a class="slnk01" href="#chpt07">Рандом генер.</a></li>
<li><a class="slnk01" href="#chpt08">Символы и строки.</a></li>
<li><a class="slnk01" href="#chpt09">Массивы.</a></li>
<li><a class="slnk01" href="#chpt10">Процедуры и функции.</a></li>
<li><a class="slnk01" href="#endin">В конец документа.</a></li>
</ol>

<hr><!--████████████████████████████-->

<a name="chpt01">
<h1>Глава 1. Структура программы.
</h1>
</a>

<p>Программа состоит из следующих разделов:
</p>

<ul>
<li>Program PrName001; </li>Заголовок программы. Имя указывается любое, в рамках грамматики языка.
<li>Uses ; </li>Перечень подключаемых модулей.
<li>Label ; </li>Перечень меток, которые будут использованы в программе.
<li>Const ; </li>Список констант.
<li>Type ; </li>Объявление пользовательских типов данных.
<li>Var ; </li>Объявление переменных.
<li>Procedure ; </li>Создание процедур, выполняемых в ходе программы для определённых целей.
<li>Function ; </li>Создание функций, для назначения пользовательских формул.
<li>begin </li>Начало программы.
<li>... </li>Тело программы, алгоритм из операторов.
<li>end. </li>Конец программы, в конце должна стоять точка. Последний оператор перед этим ключевым словом может не заканчиваться точкой с запятой.
</ul>

<p>Разделы имеют свои назначения, свой порядок. Рекомендуется следовать указанному порядку. Хотя обязательным разделом является только название программы, тело и завершение. Подключаемые модули перечисляются через запятую, и позволяют использовать больше стандартных операторов. Метки позволяют переключить выполнение программы на определённые места, возвращаясь либо перепрыгивая определённую часть алгоритма, но для этого есть специальные операторы, поэтому стоит использовать в крайнем случае. Константы - это объекты программы, значение которых нельзя переопределить с начала выполнения программы. Типы - это вид данных, назначенный пользователем. Поскольку все стандартные типы уже существуют, раздел используется редко. Переменные - объекты, которым можно назначать значение и менять его в процесе выполнения программы. Процедуры - подпрограммы, выполняющие свою роль, могут использоваться несколько раз, и для этого выносятся в раздел объявлений для упрощения кода. Функции - аналогично процедурам, только их отличием будет обязательный возврат значения. begin и end - ключевые слова, используемые также в процедурах и других некоторых местах программы. Для определения начала и конца тела программы, единожды они должны присутствовать.
</p>

<hr><!--████████████████████████████-->

<a name="chpt02">
<h1>Глава 2. Практика, ввод-вывод.</h1>
</a>

<p>Для начала, нужно иметь под рукой среду разработки. Теория без практики не так полезна и интересна. Когда имеем под рукой компилятор, и умеем его запускать, можно пробовать создавать простые программы. Проще сразу сохранять их на локальное хранилище машины, на раздел диска. Для этого стоит выбрать удобную директорию, либо оставить имеющуюся. Затем, редактируемый код нужно сохранить, формат *.pas будет подходящим. Потом набираем код, периодически его сохраняя, редактируя и проверяя. После проверки на ошибки приступаем к его компиляции - созданию машинного модуля. Если всё пройдёт удачно, получим соответствующее сообщение, и также в директории должен появиться *.exe - файл, готовый для использования вне среды разработки. В моём случае начал жаловаться антивирус, но угрозы реальной не было. Далее можно выполнять программу, комбинация ctrl+F9 работает для этого действия. Наблюдаем результат.
</p>

<img src="img/1.png"><br>
<img src="img/2.png"><br>
<img src="img/3.png"><br>
<img src="img/4.png"><br>
<img src="img/5.png"><br>
<img src="img/6.png"><br>
<img src="img/7.png"><br>

<p>Теперь активное введение в код указанной программы. Имя выбрано, модуль CRT подключен, одна переменная X типа integer будет использована. Этот тип означает целое число определённого диапазона и объема резервированной памяти. Функция clrscr (находится в библиотеке CRT) предписывает очистить экран программы, потому что он со временем выглядит немного переполненным устаревшими либо ненужными символами. Оператор write () выводит на экран информацию, при этом символьная информация указана в '...' таких кавычках, а переменные стандартных типов перечисляются обычными запятыми. Операторы Write и Writeln отличаются тем же, чем и Read с Readln - вторые варианты после завершения работы переводят строку вниз к началу. Read (х) записывает значение в переменную х. Для вывода двойного значения можно использовать и вторую переменную, с оператором присваивания := . Это имело бы такой вид:
</p>

<p style="color:blue">Write ('Введи число - ');<br>
readln (x);<br>
y:=x*2;<br>
Write (y,' - это оно.');
</p>

<p>Для этого стоит в разделе переменных указать эту новую. При определении её типа, нужно помнить, какие значения ей придётся принимать, потому что иногда в неправильно выбранном типе скрывается ошибка, приводящая к необычным результатам работы программы. Пример - при сортировке вещественных чисел промежуточная переменная имеет целочисленный тип. Тогда программа будет работать, но правильный результат не увидим. Последний оператор readln призван дождаться нажатия пользователя, после чего программа заверщит работу. Это довольно гибкий и сырой код. Красиво работающая программа даёт пользователю более понятный интерфейс с перечисленными вариантами действий, и защитой от ошибочных нажатий, равно как и прочие положительные моменты.
</p>

<p>Среда разработки может содержать несколько окон с данными. Результаты выполнения программы после её завершения в компиляторе можно просмотреть, через опцию output в верхнем меню debug. Затем, окно просмотра результата можно закрыть и вернуться к разработке.
</p>

<hr><!--████████████████████████████-->

<a name="chpt03">
<h1>Глава 3. Таблицы цветов, типов.</h1>
</a>

<p>Оформление текста изменением его цвета и цвета его фона. 
</p>

<img src="img/13.png"><br>

<p style="color:blue">textcolor(red);<br>
textbackground(white);<br>
write('123');
</p>

<p>Эти команды меняют весь последующий вид отображаемого содержимого. Для отмены нужно переопределить команды повторно со стандартными значениями. Ниже приведены значения цветов, которые можно использовать. Для фона нельзя использовать все цвета, что и для текста. То бишь они повторяют восемь цветов. Для текста определены шестнадцать. Номер цвета начинается с нуля. На изображении показано числами. Далее находится таблица типов переменных, с описанием диапазона значений для каждого типа.
</p>

<table style="float:left" border="4">
<caption>Цвета</caption>
<tr>
<th>TextColor</th>
<th>TextBackground</th>
<th>Число</th>
</tr>
<tr>
<td>black</td>
<td>black</td>
<td>0</td>
</tr>
<tr>
<td>blue</td>
<td>blue</td>
<td>1</td>
</tr>
<tr>
<td>green</td>
<td>green</td>
<td>2</td>
</tr>
<tr>
<td>cyan</td>
<td>cyan</td>
<td>3</td>
</tr>
<tr>
<td>red</td>
<td>red</td>
<td>4</td>
</tr>
<tr>
<td>magenta</td>
<td>magenta</td>
<td>5</td>
</tr>
<tr>
<td>brown</td>
<td>brown</td>
<td>6</td>
</tr>
<tr>
<td>lightgray</td>
<td>lightgray</td>
<td>7</td>
</tr>
<tr>
<td>darkgray</td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>lightblue</td>
<td></td>
<td>9</td>
</tr>
<tr>
<td>lightgreen</td>
<td></td>
<td>10</td>
</tr>
<tr>
<td>lightcyan</td>
<td></td>
<td>11</td>
</tr>
<tr>
<td>lightred</td>
<td></td>
<td>12</td>
</tr>
<tr>
<td>lightmagenta</td>
<td></td>
<td>13</td>
</tr>
<tr>
<td>yellow</td>
<td></td>
<td>14</td>
</tr>
<tr>
<td>white</td>
<td></td>
<td>15</td>
</tr>
</table>

<table border="4">
<caption>Заголовок</caption>
<tr>
<th>Тип данных</th>
<th>Описание диапазона</th>
</tr>
<tr>
<td>byte</td>
<td>0 +255 целые</td>
</tr>
<tr>
<td>integer</td>
<td>-32768 +32767 целые</td>
</tr>
<tr>
<td>word</td>
<td>0 +65535 целые</td>
</tr>
<tr>
<td>longint</td>
<td>-2147483648 +2147483647 целые</td>
</tr>
<tr>
<td>real</td>
<td>-2,9*10<sup>39</sup> +1.7*10<sup>38</sup> вещественные, 11 знаков после запятой</td>
</tr>
<tr>
<td>char</td>
<td>Один символ</td>
</tr>
<tr>
<td>string</td>
<td>Строка не больше 255 символов. string[X] - Х символов</td>
</tr>
<tr>
<td>boolean</td>
<td>ложь/истина</td>
</tr>
</table>

<p style="clear:both">С неправильным использованием переменных на стадии компиляции может быть несколько ошибок. К примеру, не стоит использовать не объявленные переменные. Также дублировать их имена. И тому подобное. Имя переменной должно ограничиваться 63 символами, а лучше возможным минимумом.
</p>

<hr><!--████████████████████████████-->

<a name="chpt04">
<h1>Глава 4. Операции, комментарии.</h1>
</a>

<p>Оператор присваивания := может присваивать следующие моменты. Значение, соответствующее типу изменяемой переменной. Выражение, результат которого совпадает типу. Переменную с подходящим типом. Типы могут быть не обязательно одинаковыми, но переменная должна суметь принять значение, или оно будет утрачено, либо изменено по какой-то системной формуле, непригодной для правильной работы программы. Символьные константы можно присвоить символьным переменным, тогда эти переменные не будет необходимости окружать кавычками '' при работе самих переменных. При присваивании можно изменять значение переменной - x:=x+10; - увеличение значения переменной на 10.
</p>

<p>Вывод данных можно использовать так - write (a,b,c,'текст',d,e+f). Это наглядно показывает, как символьная константа располагается вокруг переменных. Все эти переменные отобразят на экране свои значения, и даже без пробелов между ними, но способ отчётливо виден, как сделать всё более доступно. Также можно в списке переменных производить стандартные операции, и последним значением отобразится сумма значений переменных e и f.
</p>

<p>Ввод данных через оператор readln (a,b,c) позволяет ввести с клавиатуры значения для переменных, в данном случае сразу трёх. Вводить нужно с учётом правильного типа вводимых данных, иначе без защиты программа просто прекратит работу. Символьную информацию вводить нужно для символьных переменных, числовую аналогично.
</p>

<p>Арифметические операции обозначаются символами + сложение - вычитание * умножение / деление, ещё есть div - возвращает целое значение при делении, и mod - возвращает остаток от деления. Использование скобок актуально, приоритет выполнения операций стандартный - сложение вычитание обрабатываются последними, все остальные по порядку.
</p>

<p>Комментарии нужны для того, чтобы часть кода не компилировалась, но присуствовала. Применяется для пояснения модулей программы, с целью упрощённого восприятия или для понимания другими пользователями, читающими код. (* *) вот в таких скобках код будет игнорироваться.
</p>

<p>Вещественные, то бишь не целые, косые, неровные числа могут быть использованы тоже. Отображение таких чисел будет по умолчанию некомфортным. К примеру, число 123,456 будет записано как 1,23456000000000E+002. Это можно расценивать как равенство 123,456 = 1,23456*10<sup>2</sup>. 1,23456 - мантисса, значение ставится между 1 и 10, всё остальное сдвигается в множитель 10 со степенью, равной сдвигу точки. Такая запись называется плавающей точкой, но для бытовых случаев намного комфортнее использовать обычную фиксированную точку 123,456 вида.
</p>

<p>Форматированный вывод вещественного значения - write (X:5:1); будет означать, что отображаемому значению дают пять позиций, из которых 1 обозначена для дроби. Ещё для запятой позиция, и на целое остаётся 3 позиции. Стоит учитывать, что целое число будет выведено правильно независимо от выделенных позиций, а дробная будет содержать указанное число позиций, обрезая лишние либо добавляя нули. Пример - число выводится как 5:2 - пять позиций, две дробных. Выводим 1234,567 - получим 1234,56. Выводим 1,1 - получим 1,10.
</p>

<p>Преобразование типов данных. При операциях с целыми числами, типом результата будет целое. Если участвует вещественное, результат будет вещественный. Если производится деление, даже целых, результат будет вещественным. Далее фрагменты кода, связанные с операциями и присваиванием.
</p>

<table style="color:blue" width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>x:=1+1;</td>
<td>x=2</td>
</tr>
<tr>
<td>x:=2-1;</td>
<td>x=1</td>
</tr>
<tr>
<td>x:=1*2;</td>
<td>x=2</td>
</tr>
<tr>
<td>x:=2/2;</td>
<td>x=1</td>
</tr>
<tr>
<td>x:=5 div 2;</td>
<td>x=2</td>
</tr>
<tr>
<td>x:=5 mod 2;</td>
<td>x=1</td>
</tr>
<tr>
<td>x:=round(1,9);</td>
<td>x=2</td>
</tr>
<tr>
<td>x:=trunc(1,9);</td>
<td>x=1</td>
</tr>
</table>

<p>Две последних функции возвращают целое значение. Первая из них округляет до ближнего целого. При ровной середине дробного значения округление будет вниз. Вторая функция просто откидывает дробную часть. Они обе должны возвращать значение целочисленного типа. Далее ещё несколько стандартных функций для работы с числами.
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>abs(x)</td>
<td>модуль</td>
</tr>
<tr>
<td>sin(x)</td>
<td>синус, радианы</td>
</tr>
<tr>
<td>cos(x)</td>
<td>косинус</td>
</tr>
<tr>
<td>arctan(x)</td>
<td>арктангенс</td>
</tr>
<tr>
<td>ln(x)</td>
<td>логарифм по е</td>
</tr>
<tr>
<td>exp(x)</td>
<td>е в степени х</td>
</tr>
<tr>
<td>sqr(x)</td>
<td>квадрат х</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td>треугольный корень</td>
</tr>
<tr>
<td>int(x)</td>
<td>целая часть тип real</td>
</tr>
</table>

<hr><!--████████████████████████████-->

<a name="chpt05">
<h1>Глава 5. Условные операторы и безусловный переход.</h1>
</a>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td><</td>
<td>меньше</td>
</tr>
<tr>
<td>></td>
<td>больше</td>
</tr>
<tr>
<td>=</td>
<td>равно</td>
</tr>
<tr>
<td><=</td>
<td>меньше или равно</td>
</tr>
<tr>
<td>>=</td>
<td>больше или равно</td>
</tr>
<tr>
<td><></td>
<td>не равно</td>
</tr>
</table>

<p>Условный оператор if предназначен для выявления истинности следующего за ним выражения. Выражение записывается с использованием перечисленных выше операций сравнения.
</p>

<p style="color:blue">if a>b<br>
then writeln(a,' большее из них.')<br>
else writeln(a,' не большее из них. могут быть равны.');
</p>

<p>Можно использовать сокращенный вариант оператора. if ... then ... ; Такого вида. В случае ложности выражения просто ничего не будет предпринято. На этом этапе можно дать первую задачку для ума, совсем лёгкую. Ввести три любых числа, определить и вывести большее из них. Код ниже.
</p>

<p style="color:blue">program pr001;<br>
uses crt;<br>
var x,y,z,max:integer;<br>
begin<br>
clrscr;<br>
writeln('Введите число:');<br>
readln(x);<br>
writeln('Введите число:');<br>
readln(y);<br>
writeln('Введите число:');<br>
readln(z);<br>
max:=x;<br>
if y>max then max:=y;<br>
if z>max then max:=z;<br>
writeln('Максимальное - ',max);<br>
readln<br>
end.
</p>

<p>Особо ничего сложного. Назначается максимальным первое. Сравнивается со вторым. Сравнивается с третьим. Во время сравнений либо заменится, либо останется.
</p>

<p>Составной оператор. Вместо одного оператора можно выполнять несколько, только оформить их в begin-end.
</p>

<p style="color:blue">if &lt;условие&gt; tnen<br>
begin &lt;оператор&gt;; &lt;оператор&gt;; (*Перед end знак не нужен. Но не запрещён.*)<br>
end (*Здесь ставить знак нельзя, перед else.*)<br>
else<br>
begin &lt;оператор&gt;; &lt;оператор&gt;;<br>
end; (*А тут знак положен - завершение условного оператора.*)
</p>

<p>Логические переменные и операции. В разделе объявления переменных назначается тип boolean. Любая операция логического типа возвращает значение истина (true) - ложь (false). Переменная, принявшая это значение, может быть использована в условном операторе. Присваивание можно сделать прямым -- L:=true;
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>X Y</td>
<td>X and Y</td>
<td>X or Y</td>
<td>X xor Y</td>
</tr>
<tr>
<td>1 1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1 0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0 1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0 0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>

<p>Операции можно выполнять с одним или несколькими логическими переменными. Пример -- вычислить, являются ли истинными два выражения, или одно из них, и вроде этого. Операция с одним логическим значением (унарная) может быть только заменой на противоположное. X:=not(Y); Операции с несколькими выражениями считаются так. Логическое умножение and даёт плюс, если все слагаемые истинны. Логическое сложение or даёт плюс, если присутствует хоть одное истинное. Исключающее или, xor, истинно при разности значений, и ложно, если все слагаемые имеют одинаковое значение. Как и в арифметике, есть приоритет выполнения в сложных выражениях. Not выполняется первой, And второй, Xor и Or последними. Использование скобок увеличивает приоритет.
</p>

<img src="img/8.png"><br>

<p>Оператор Case. Структура. Использование множества значений х..у. Составной оператор. Хотя его удобнее превратить в функцию/процедуру и использовать вызовом имени, но об этом потом. 
</p>

<img src="img/9.png"><br>

<p>Здесь же показана метка. Label - раздел объявлений. Метка ставится в формате lname: . Затем используется оператор безусловного перехода Goto. Хотя для его использования обычно предусматриваются условия, они реализуются во внешней конструкции, в Case или If. Иначе программа рискует стать невыполнимой, бесконечной.
</p>

<hr><!--████████████████████████████-->

<a name="chpt06">
<h1>Глава 6. Циклы.</h1>
</a>

<p style="color:blue">for x:=1 to 50 do<br>
begin<br>
write (x,' ')<br>
end;<br>
for x:=50 downto 1 do<br>
begin<br>
write (x,' ')<br>
end;
</p>

<p>Здесь переменная х выступает в роли счетчика цикла. Счетчик может быть только порядкового типа. То бишь он определит своё прошлое и следующее значение. Вещественные числа не подходят определённо. Символьные и булевские подойдут, но используются редко, куда удобнее целочисленные. Телом цикла может быть оператор простой либо составной. Нельзя переопределить значение счетчика, чтобы повлиять на ход цикла, но можно использовать для определения других переменных. По окончании счетчик автоматически прибавит единицу. Тело цикла будет совершено в последний раз, когда счетчик равен конечному значению.
</p>

<p style="color:blue">repeat {тело} until {условие};
</p>

<p>Тело может быть одним или несколькими операторами. begin end использовать здесь не обязательно. Цикл будет произведён минимум один раз, затем будет постпроверка условия. В случае истинности цикл будет завершён.
</p>

<p style="color:blue">while {условие} do {тело};
</p>

<p>Проверка выполняется вначале. Если условие ложно, цикл не будет выполнен. Если истинно, то будет выполняться. Тело включает простой или составной оператор. Ещё одна задачка для ума. Любое введенное число нужно разложить на простые множители. Простые - делятся только на себя и на единицу. Любое сложное число можно выразить произведением простых. Примерный алгоритм для числа 100.<br>
100/2=50. делится нацело на 2 - первый множитель.<br>
50/2=25.<br>
25/2♦25/3♦25/4♦25/5=5. делить на 4 глупо, потому что 25 тогда разделилось бы и на 2. Но иначе никак.<br>
5/2♦5/3♦5/4♦5/5=1.
</p>

<img src="img/10.png"><br>

<p>Нет времени объяснять. Программа работает, и то ладно. Вникать в мелочи долго.
</p>

<hr><!--████████████████████████████-->

<a name="chpt07">
<h1>Глава 7. Генератор псевдослучайностей.</h1>
</a>

<p>Команда randomize; инициализирует генератор. Функция random(X) возвращает любое число в интервале 0..Х-1. Например, n:=random(10) присвоит n значение 0..9. Разрешена такая примочка - n:=(random(10)+1); Глава короткая, но интересная. Этот псевдогенератор не идеален, поэтому стоит поискать расширенные способы.
</p>

<hr><!--████████████████████████████-->

<a name="chpt08">
<h1>Глава 8. Символы, строки.</h1>
</a>

<p>American standard code for information interchange, ASCII. В текстовом редакторе компилятора видны не все символы. Но основные объяснить можно. Во многих стандартных редакторах можно написать символ, удерживая alt и набирая код. Есть специфичные символы вроде 10 - он не отображается, но обозначает перевод строки. Суть символа в том, чтобы графически отображать информацию. Для других операций символы бесполезны. Всего в таблице их 255. Нулевой и 256-й не выводятся. При продолжении нумерации будет простой повтор.
</p>

<img src="img/14.png"><br>

<p>Переменные символы, точнее символьные переменные, в разделе объявления имеют тип char. Символьные константы указываются в 'таких скобках'. ch:='5'; Предыдущая запись гласит, что переменная ch получила значение 5, вот только эта пятёрка не будет полезной для арифметических операций - она символ.
</p>

<p>Символьные константы можно сравнивать. При этом будет использован ASCII-код.
</p>

<p>x:char; x:=chr(170); x='к'. Это функция chr(), она из кода возвращает символ.
</p>

<p>x:integer; x:=ord('к'); x=170. Это функция ord(), она из символа возвращает код.
</p>

<p>Строковые переменные объявляются s:string[X]; Х является ограничением количества символов, и не является обязательным пунктом переменной, по умолчанию имеющей максимальную длину 255 символов. Присваивание такое - str:='слово'; Сложение строковых переменных подобно числовым - последовательное соединение. Складывать строковые переменные со строковыми константами также возможно, используя известные скобки.
</p>

<p>Х[5] представляет собой обращение к пятому символу в строковой переменной. chr01:=strk[1];
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>chr(x)</td>
<td>возвращает символ из номера</td>
</tr>
<tr>
<td>ord(ch)</td>
<td>возвращает номериз символа</td>
</tr>
<tr>
<td>length(s)</td>
<td>возвращает длину строковой переменной</td>
</tr>
<tr>
<td>copy(s,n,l)</td>
<td>из строки S копирует L символов, начиная с N</td>
</tr>
<tr>
<td>delete(s,n,l)</td>
<td>из строки S удаляет L символов, начиная с N</td>
</tr>
<tr>
<td>readkey</td>
<td>считывает нажатый символ</td>
</tr>
<tr>
<td>keypressed</td>
<td>определяет факт нажатия. неуместно, но пусть тут.</td>
</tr>
</table>


<hr><!--████████████████████████████-->

<a name="chpt09">
<h1>Глава 9. Массивы.</h1>
</a>

<p>X: array[1..10] of integer;
</p>

<p>1..10 - границы массива. Допускается для границ использовать любые порядковые значения, даже символьные. Нижняя позиция должна быть меньше верхней. На одну переменную есть ограничение памяти 64 КБ - учесть для объёмных массивов. Элементы массива могут быть символьными или булевскими, при должном типе.
</p>

<p>При вдумчивом изучении натолкнулся на бред. x:array['b'..'f'] of char=('2','4','Z','8','0');<br>
Отсюда следует, что x['d']=Z. По сути логично, но зачем... При заведении цикла счётчик приходится делать символом. Путает только. Символьная константа играет роль элемента массива, который может равняться любому другому значению другого типа.
</p>

<p>Назначение при объявлении. str:array[1..3] of string=('кто','где','как');
</p>

<p>Wm: array[1..5,1..5] of integer; Это двумерный массив. 5х5, вроде таблицы. Ниже примерный и бесполезный код использования двумерного массива.
</p>

<img src="img/11.png"><br>

<p>Довольно ёмкий материал - сортировка массивов. Ради забавы попробовал сам смастерить - но только сломал мозг.
</p>

<img src="img/16.png"><br>

<p>Разобраться с этим можно позднее. Изучить и понять.
</p>

<p>Есть ещё способы сортировки по невозрастающему убыванию вверх, и в другие стороны.. И ещё много применений для двумерных массивов. Раздел будет дополняться при необходимости.
</p>

<hr><!--████████████████████████████-->

<a name="chpt10">
<h1>Глава 10. Процедуры и функции.</h1>
</a>

<p>Всё просто. Скриншот с кодом, и разъяснение.
</p>

<img src="img/15.png"><br>

<p>Функции объявляются в соответствующем разделе. Имеют имя, тип своего значения, формальные параметры. Собственные разделы, переменные и тело функции. Переменные и константы, указанные в функции, используются только в ней, поэтому имена можно дублировать с внешними. Друг на друга они не влияют. За исключением формальных параметров функции - они тоже могут взять имя, использованное во внешнем теле, а значение они принимают именно из фактических параметров при обращении к функции.
</p>

<p>На конкретном коде - переменной х мы хотим придать значение операций, проведённых с ней. Вызываем функцию с этими операциями, сообщив параметр х. Значение фактического параметра х передаётся формальному параметру а внутри функции (можно было формальный параметр тоже назвать х). Внутри функции есть переменная z. Производятся необходимые операции, ввод-вывод, устойчивая часть программы. Обязательным условием является присвоение функции некоторого значения -- оно и будет возвращено вызывающей переменной, здесь результатом мы увидим 50. Существуют и нулевые функции, без формальных параметров и возврата значения, но условие нужно соблюсти - хотя бы присвоить функции значение 0. Вызвать функцию простым названием (fucsia), увидеть её работу и двигаться дальше.
</p>

<p>Процедуры. Несколько стандартных.
</p>

<table width="" border="" cellspacing="" cellpadding="" summary="">
<caption></caption>
<tr>
<td>delay(ms)</td>
<td>задержка времени милисекунды</td>
</tr>
<tr>
<td>exit</td>
<td>завершает текущую структуру</td>
</tr>
<tr>
<td>halt</td>
<td>завершает работу приложения</td>
</tr>
<tr>
<td>gotoxy(x,y)</td>
<td>перевод курсора в Х,У</td>
</tr>
<tr>
<td>str(x,s)</td>
<td>перевод числа в строку</td>
</tr>
<tr>
<td>val(s,x,n)</td>
<td>перевод строки в число. n=0, либо порядок символа, вызвавшего сбой</td>
</tr>
</table>

<p>Пользовательские процедуры немного сложнее в плане количества особенностей.
</p>

<img src="img/17.png"><br>

<p>При имени процедуры указываются формальные параметры. И даже тут они делятся на два типа. Первый -- параметр-значение (a,b). Они принимают значение фактического параметра, константу, выражение. Если соотвествует переменная, в ходе работы процедуры она во внешней структуре не изменится, изменения останутся внутри процедуры, даже если имена переменных будут одинаковыми. Второй тип в этом отличается. Параметр-переменная (c) принимает адрес фактической переменной в памяти, и изменения коснутся её. То бишь, при вызове функции соответствующий фактический параметр должен быть только переменной. Естественно, всегда нужно учитывать количество и порядок фактических параметров при вызове. В процедуре можно использовать переменные локальные (m,n) и глобальные (abc). Локальные могут именами совпадать с переменными во внешней программе, но значения у них сохранятся внутри своих структур раздельно. Глобальные переменные описаны во внешней структуре, и изменятся при операциях с ними внутри процедуры.
</p>

<p>Если во внешней системе были переменные a,b,m,n, то после выполнения процедуры они останутся прежними. Вывести их в процедуре -- увидим локальные значения. Вывести во внешней -- увидим предыдущие. Но если они переданы в параметр-переменную (c), или не описаны как локальные, то будут изменены глобально.
</p>

<img src="img/18.png"><br>

<p>Процедуры и функции могут вызывать себя и себе подобных изнутри. А ещё они могут вызывать самих себя. Довольно трудно найти проблему, решение которой будет затрагивать этот способ, но это реально. Выше -- пример, программа вычисляет вещественное a в целой положительной степени n. Задействована рекурсия - обращение к самой себе. При желании можно попробовать проанализировать ход действия программы.
</p>

<hr><!--████████████████████████████-->

<a href="tp7konsp2c.html">Вторая часть.</a><br>

<hr><!--████████████████████████████-->

<a href="#strt" name="endin">В начало документа.</a><br>
</div>

	</body>
<!--████████████████████████████-->
<!--████████████████████████████████████████████████████████-->
	</html>

<!--

 style="color:blue"
<img src="img/1.png"><br>
&lt открывающий тег
&gt; закрывающий тег

<> &lt;&gt;
<></> &lt;&gt;&lt;/&gt;
</> &lt;/&gt;

<pre></pre>

<p>
</p> абзац
<h1></h1>
<h2></h2>
<h3></h3>
<h4></h4>
<h5></h5>
<h6></h6>

-->
<!--████████████████████████████████████████████████████████████████████████████████████-->